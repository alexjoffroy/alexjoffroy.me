---
title: Quelques astuces pour booster votre nouveau site
seo_title: Quelques astuces pour booster votre nouveau site
seo_description: Lorsque que je publie un nouveau site, je v√©rifie ses performance en utilisant des outils tels que WebPageTest. J'obtiens ainsi une analyse compl√®te avec diff√©rentes pistes pour l'am√©liorer. Examinons ensemble quelques am√©liorations faites sur ce blog.
---
Lorsque que je publie un nouveau site, je v√©rifie ses performance en utilisant des outils tels que [WebPageTest](https://www.webpagetest.org). J'obtiens ainsi une analyse compl√®te avec diff√©rentes pistes pour l'am√©liorer.

Ce blog n'a pas fait exception et les r√©sultats ont √©t√© flagrants: un C pour le "First-Byte time" et un F pour "Cache static assets" et "Compress images". De plus, mon [Speed index](https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/metrics/speed-index) √©tait aux alentours de 1400; pas trop mal mais plus √©lev√© que le max recommand√© (1000).

Visiblement, je pouvais am√©liorer certaines choses.

## Compresser les images

Les images sont un point important quand on commence √† parler de performance, car ce sont souvent les fichiers les plus lourds. Malgr√© tout, on peut facilement r√©duire leurs tailles. Sur ce blog, j'utilise une seule image, dans le header. Avant optimisation elle pesait ~1.1mo ... plus de 90% du poids total de mes resources !

Sur mon Mac, j'utilise `imagemagick` pour compresser mes images [en suivant quelques r√©gles](https://developers.google.com/speed/docs/insights/OptimizeImages#optimizations-for-gif-png-and-jpeg-images) :

```bash
 magick convert INPUT.jpg -sampling-factor 4:2:0 -strip -quality 85 -interlace JPEG -colorspace Gray OUTPUT.jpg
```
R√©gler la qualit√© √† 85 permet de r√©duire consid√©rablement la taille du ficher, tout en gardant un bon rendu visuel. Dans mon cas, j'ai m√™me d√©cid√© de la r√©duire √† 50.

Avec √ßa, la taille finale de mon image n'est plus que de 173ko. Parfait !

Au del√† de la compression, il faudrait √©galement consid√©rer l'utilisation des [images responsives](https://developers.google.com/web/fundamentals/design-and-ux/responsive/images). 


## R√©duire la taille des CSS/JS

Pour r√©duire la taille des CSS/JS, une √©tape incontournable est la minification.
Si, comme moi, vous utilisez [Laravel mix](https://laravel.com/docs/5.6/mix), c'est tr√®s simple:

```bash
# yarn or npm
yarn run production
```

Cette commande execute la t√¢che `production` qui va minifier les ressources sans configuration suppl√©mentaire. 

Malgr√© tout, il faut tout de m√™me faire attention √† ce que l'on inclut dans nos CSS ou JS. Sur des groses biblioth√®ques, comme Bootstrap, il est souvent possible d'importer les modules individuellement. Cela permet de r√©duire la taille finale des ressources, en gardant uniquement le n√©cessaire.

Sur ce projet, j'ai utilis√© [TailwindCSS](https://tailwindcss.com/), un r√©cent framework CSS utility-first, et il s'est av√©r√© tr√®s pratique. En gros, l'id√©e est d'√©crire tout son CSS sous forme de classes utilitaires et les appliquer ensuite directement dans son HTML. J'√©tais plut√¥t sceptique la premi√®re  fois que j'en ai entendu parler, mais maintenant je me dis que c'√©tait le maillon manquant dans mon workflow front-end. √Ä titre d'introduction, je recommande [ce post par Adam Wathan](https://adamwathan.me/css-utility-classes-and-separation-of-concerns/), l'un des cr√©ateurs de TailwindCSS.

Le principal "revers" de TailwindCSS concerne la taille du CSS compil√©. Cela est principalement d√ª au fait que TailwindCSS fournit √©norm√©ment d'utilitaires dans sa config par d√©faut: breakpoints (5 tailles d'√©crans), couleurs (10 couleurs et 7 nuances pour chacunes), etc. Heureusement, TailwindCSS est facilement param√®trable et la documentation dispose d'une page consacr√©e [au contr√¥le de la taille du fichier](https://tailwindcss.com/docs/controlling-file-size).

L'un des points abord√©s est l'usage de PurgeCSS, un outil pour retirer automatiquement le CSS inutilis√© d'un projet. La bonne nouvelle c'est que l'on peut facilement l'ajouter √† notre workflow Laravel Mix, comme expliqu√© dans la documentation. Encore mieux, il y a [un plugin par Spatie](https://github.com/spatie/laravel-mix-purgecss) pour g√©rer √ßa:

```bash
yarn add laravel-mix-purgecss
```

Ensuite, il suffit d'√©crire:

```js
const mix = require('laravel-mix');

require('laravel-mix-purgecss');

// Here are your build task like mix.sass or mix.js

mix.purgeCss();

```

Si vous n'utilisez pas de librairies externes, cela devrait suffire ! Sinon, il faudra surement un peu de config. Par d√©faut, le plugin recherche les classes √† garder uniquement dans les r√©pertoires `app` et `resources`. Cela signifie que toutes les CSS issues des `node_modules` seront supprim√©es du fichier de sortie. Pour √©viter cela, il faut explicitement dire √† PurgeCSS ce que l'on veut garder:

```js
mix.purgeCss({
    globs: [
        // Keep all classes found in JS files in 'node_modules/simplemde'
        path.join(__dirname, 'node_modules/simplemde/**/*.js'),
    ],
    // Keep all classes matching these patterns
    whitelistPatterns: [/hljs/, /noty/],
})
```

Sur ce site, la taille de mon fichier est pass√©e de 240ko √† 16.5ko üí™. Vous trouverez [ma config sur Github](https://github.com/alexjoffroy/alexjoffroy.me/blob/262124fc309c6662fcb217a2d53cc1f5284f1b07/webpack.mix.js).


## Polices

Comme beaucoup de gens, j'aime utiliser Google Fonts sur mes projets. Cependant, il y a quelques astuces √† savoir pour en optimiser l'usage.

D√©j√†, j'essaie de limiter le nombre de polices, mais √©galement de graisses. Cela rend l'import bien plus l√©ger. Ici, j'ai essay√© d'utiliser uniquement les graisses "normal" et "gras", et d'utiliser plut√¥t les nuances de couleurs pour d√©finir l'importance (plus clair = moins important, plus fonc√© = plus important).

Une astuce que je ne connaissais pas consiste √† importer toutes les polices en une seule fois gr√¢ce √† l'op√©rateur `|`:

```html
<!-- Avant -->
<link href="https://fonts.googleapis.com/css?family=Montserrat:400,700" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Satisfy" rel="stylesheet">

<!-- Apr√®s -->
<link href="https://fonts.googleapis.com/css?family=Montserrat:400,700|Satisfy" rel="stylesheet">
```

D'ailleurs, j'utilise la police Satisfy uniquement pour mon logo. Je me demande s'il serait judicieux de remplacer cela par un SVG, mais actuellement je ne sais pas ce qui est le mieux.

Dernier truc pour booster Google Fonts: le lien `preconnect`. C'est [tr√®s bien expliqu√© ici](https://www.cdnplanet.com/blog/faster-google-webfonts-preconnect/), en anglais.

> Le type de relation "preconnect" est utilis√© pour indiquer une origine qui sera utilis√©e pour r√©cup√©rer des ressources. L'initialisation d'une connexion pr√©coce, incluant les n√©gociations DNS, TCP et TLS, permet de masquer la latence √©lev√©e li√©e √† l'√©tablissement d'une connexion.

Il suffit d'ajouter dans son`head`:
```html
<link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin>
```

Le lien `preconnect` doit √©galement √™tre utile si vous utilisez des domaines externes, comme des CDNs, pour r√©cup√©rer d'autres ressources.

## Quelques optimisations c√¥t√© serveur

Maintenant que nos ressources sont pr√™tes, allons configurer le serveur web. J'utilise Nginx mais Apache sait faire la m√™me chose.


### Activer la compression GZIP

D√©j√†, v√©rifiez que GZIP est activ√©. Sur mon serveur, tout √©tait d√©j√† OK, mais sinon c'est assez facile √† faire. Il suffit d'ouvir le fichier de config `/etc/ngninx/nginx.conf`, et de rechercher la section GZIP. Puis, d√©commentez les param√®tres par d√©faut:

```bash
gzip on;
gzip_disable "msie6";

gzip_vary on;
gzip_proxied any;
gzip_comp_level 6;
gzip_buffers 16 8k;
gzip_http_version 1.1;
gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript application/vnd.ms-fontobject application/x-font-ttf font/opentype image/svg+xml image/x-icon;
```

Comme vous pouvez le voir, on peut choisir les types MIME √† compresser. Les images (et musiques, vid√©os, PDFs, ...) sont d√©j√† compress√©es donc il n'y a pas besoin de les recompresser avec GZIP. A vrai dire, cela pourrait m√™me √™tre pire, comme on peut [le lire ici](https://webmasters.stackexchange.com/questions/8382/gzipped-images-is-it-worth), en anglais.

Red√©marrez Nginx:
```bash
sudo service nginx restart
```

V√©rifiez que tout fonctionne:
```bash
curl -H "Accept-Encoding: gzip" -I https://yourdomain.com/path/to/css

# Response should have the following header
Content-Encoding: gzip
```

### Activer HTTP/2

HTTP/2 existe maintenant depuis quelques temps, est compatible [avec tous les navigateurs modernes](https://caniuse.com/#search=http2), et est r√©put√© plus rapide que sa version pr√©c√©dente. Profitons en pour l'activer.

Il n√©cessite quelques pr√©requis, principalement d'utiliser HTTPS avec un certificat SSL valide. En dehors de cela, activer HTTP/2 est facile dans Nginx, il suffit d'ajouter cela dans sa config:
```bash
# /etc/nginx/sites-enable/yoursite

server {
    listen 443 ssl http2;
		
    ...
}
```
Si vous √™tes malchanceux comme moi, vous pourrez rencontrer quelques soucis:
- HTTP/2 est support√© uniquement sur Nginx >= 1.9.5
- Nginx doit √™tre compil√© avec OpenSSL >= 1.02 

Ces liens m'ont bien aid√© (en anglais):
- [Supporting HTTP/2 for Website Visitors](https://www.nginx.com/blog/supporting-http2-google-chrome-users/)
- [libssl-dev version dependency conflict with installed libssl1.0.0](https://askubuntu.com/questions/630439/libssl-dev-version-dependency-conflict-with-installed-libssl1-0-0)


### Mise en cache des ressources statiques

Enfin, g√©rons la mise en cache de nos ressources statiques (CSS, JS, images, ...). Encore une fois, facile avec Nginx. Ajoutez un bloc `location` dans votre bloc `server`:

```bash
# Cache static assets
location ~* \.(jpg|jpeg|png|gif|ico|css|js)$ {
    expires 30d;
}
```
Cela autorisera la mise en cache des fichiers JP(E)G, PNG, GIF, ICO, CSS et JS pour 30 jours.

Cependant, il y a un petit probl√®me si vous utilisez [le versioning de Laravel Mix](https://laravel.com/docs/5.6/mix#versioning-and-cache-busting). Cette fonctionnalit√© ajoute un query string aux fichiers CSS et JS, le but √©tant d'invalider le cache des fichiers lorsque ceux-ci changent. Le probl√®me avec notre config Nginx, c'est que du coup ces fichiers ne seront jamais autoris√©s √† √™tre mis en cache, justement √† cause de ce query string !

Corrigeons cela (notez le `?` √† la fin du motif):
```bash
# Cache static assets
location ~* \.(jpg|jpeg|png|gif|ico|css|js)?$ {
    expires 30d;
}
```

Bien s√ªr, vous pouvez d√©finir diff√©rentes strat√©gies selon le type de fichier:
```bash
# Cache image for 30 days
location ~* \.(jpg|jpeg|png|gif)?$ {
    expires 30d;
}

# Cache css and js for 7 days
location ~* \.(css|js)?$ {
    expires 7d;
}
```

## Conclusion

Apr√®s toutes ces optimisations (en dehors de GZIP d√©j√† activ√©), j'ai relanc√© un test sur  [WebPageTest](https://www.webpagetest.org). Les r√©sultats sont satisfaisants: uniquement des A et un speed index aux alentours de 800. M√™me si j'ai rencontr√© quelques soucis pour mettre en place ces optimisations, cela valait le co√ªt.

Je pense qu'il reste pas mal d'am√©liorations possibles, et une future √©tape √† explorer serait le cache serveur. Il existe des solutions r√©put√©es comme [Varnish](https://varnish-cache.org/) ou [nginx_fastcgi_cache](https://www.digitalocean.com/community/tutorials/how-to-setup-fastcgi-caching-with-nginx-on-your-vps). J'aimerais √©galement donner une chance √† [spatie/laravel-responsecache](https://github.com/spatie/laravel-responsecache). Vaste et beau sujet pour un prochain post !